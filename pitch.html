<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpotOrigin - Epic Pitch Deck</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        /* --- CSS VARIABLES & THEME --- */
        :root {
            --color-bg: #0A0F1C; /* Rich, deep blue-black */
            --color-text: #F8FAFC;
            --color-primary: #6366F1; /* Indigo */
            --color-secondary: #8B5CF6; /* Purple */
            --color-accent: #EC4899; /* Pink */
            --color-card-bg: rgba(30, 41, 59, 0.5); /* Slate-800/50 */
            --color-border: rgba(71, 85, 105, 0.3); /* Slate-600/30 */
            /* A smooth, sophisticated transition curve */
            --transition-smooth: cubic-bezier(0.16, 1, 0.3, 1);
        }

        /* --- CORE STYLING --- */
        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            overflow: hidden;
        }

         /* --- ENHANCEMENT: Noise Texture Overlay --- */
        body::before {
            content: "";
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
            opacity: 0.04;
            pointer-events: none;
            z-index: 1000;
        }

        /* --- DYNAMIC BACKGROUND CANVAS --- */
        #orb-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            /* Blur and opacity applied to the canvas itself for performance */
            filter: blur(130px);
            opacity: 0.35;
            /* Transition for the parallax effect */
            transition: transform 1s var(--transition-smooth);
        }

        /* --- SLIDE FRAMEWORK --- */
        .slide {
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            /* Default: center content (used for Title/Meme/End slides) */
            justify-content: center;
            align-items: center;
            scroll-snap-align: start;
            scroll-snap-stop: always;
            padding: 5vh 5vw;
            position: relative;
        }

        /* Modifier for content slides: Aligns title to the top */
        .slide-content-layout {
             justify-content: start;
             /* Added top padding for title clearance */
             padding-top: 10vh;
        }

        /* New container to center the body content vertically in the remaining space */
        .slide-body-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            flex-grow: 1; /* Allows it to take up remaining space after the title */
            width: 100%;
             /* Prevents content from getting too close to the footer */
            padding-bottom: 5rem;
        }


        main {
            height: 100vh;
            width: 100vw;
            overflow-y: scroll;
            scroll-snap-type: y mandatory;
            /* Hide scrollbars for a clean presentation look */
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }
        main::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }

        /* --- TYPOGRAPHY & CONTENT STYLING --- */
        h1, h2, h3 {
            line-height: 1.1;
        }

        /* Using clamp() for scalable, responsive typography */
        h1 {
            font-size: clamp(4rem, 8vw, 7rem);
            font-weight: 900;
            letter-spacing: -0.05em;
            text-align: center;
        }

        h2 {
            /* Slightly increased max size for more impact */
            font-size: clamp(2.8rem, 6vw, 4.5rem);
            font-weight: 800;
            letter-spacing: -0.025em;
            text-align: center;
            /* Adjusted margin for the new layout */
            margin-bottom: 2rem;
            width: 100%;
             max-width: 1200px;
        }

        h3 {
             font-size: clamp(1.5rem, 3vw, 2.25rem);
             font-weight: 700;
             letter-spacing: -0.025em;
        }

        .subtitle {
            font-size: clamp(1.25rem, 2vw, 1.8rem);
            color: #94A3B8; /* Slate-400 */
            text-align: center;
        }

        .slide-content {
             max-width: 1200px;
             width: 100%;
        }

        /* --- UI ELEMENTS: GLASSMORPHISM --- */
        .glass-card {
            background: var(--color-card-bg);
            border: 1px solid var(--color-border);
            border-radius: 1.5rem; /* rounded-3xl */
            padding: 2.5rem;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: transform 0.3s var(--transition-smooth), box-shadow 0.3s var(--transition-smooth);
        }

        /* --- UI ELEMENTS: FOOTER & PROGRESS --- */
        .progress-bar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: transparent;
            z-index: 1001;
        }

        #progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--color-primary), var(--color-secondary), var(--color-accent));
            width: 0%;
            transition: width 0.5s var(--transition-smooth);
        }

        .slide-number, .footer-note {
            position: absolute;
            bottom: 2rem;
            font-size: 0.875rem;
            color: #475569; /* Slate-600 */
            font-weight: 500;
            opacity: 0;
             transition: opacity 0.5s ease-out 0.5s;
        }

        /* Fade in footer elements when slide is active */
        .active .slide-number,
        .active .footer-note {
            opacity: 1;
        }

        .slide-number { right: 2rem; }
        .footer-note { left: 2rem; }

        /* --- ANIMATIONS: REVEALS & STAGGERING --- */
        .reveal-item {
            opacity: 0;
            /* Initial state: slightly down and scaled down */
            transform: translateY(40px) scale(0.98);
            transition: opacity 0.8s var(--transition-smooth), transform 0.8s var(--transition-smooth);
            will-change: opacity, transform;
        }

        /* Active state: fade in and move to final position */
        .active .reveal-item {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        /* Default delay for items not managed by automated staggering */
        .active .reveal-item:not([data-staggered="true"]) {
             transition-delay: 0.1s;
        }

        /* --- ANIMATIONS: SHIMMER EFFECT --- */
        @keyframes shimmer-sweep {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }

        .text-shimmer {
            position: relative;
            display: inline-block;
            overflow: hidden; /* Hide the pseudo-element when it's outside the text bounds */
            vertical-align: bottom; /* This is the fix for title alignment */
        }
        
        /* The pseudo-element creates the light sweep */
        .text-shimmer::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(
                100deg,
                rgba(255, 255, 255, 0) 20%,
                rgba(255, 255, 255, 0.5) 50%,
                rgba(255, 255, 255, 0) 80%
            );
            animation: shimmer-sweep 4s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }
        
        .fade-in-button {
            opacity: 0;
            transform: translateY(-20px);
            animation: fadeInButton 0.8s var(--transition-smooth) 1.2s forwards; /* 1.2s delay */
        }

        @keyframes fadeInButton {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* --- SLIDE SPECIFIC ENHANCEMENTS --- */
        .glitch-text {
            position: relative;
            display: inline-block;
        }
        .active .glitch-text {
             animation: glitch-skew 1s infinite linear alternate-reverse;
        }
        .glitch-text::before, .glitch-text::after {
            content: attr(data-text);
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: transparent;
            overflow: hidden;
            clip: rect(0, 900px, 0, 0);
        }
        .glitch-text::before {
            left: 3px;
            text-shadow: -3px 0 #00FFFF; /* Cyan */
        }
        .glitch-text::after {
            left: -3px;
            text-shadow: -3px 0 #FF00FF, 3px 3px #FF00FF; /* Magenta and Red */
        }
        .active .glitch-text::before {
            animation: glitch-anim-1 2s infinite linear alternate-reverse;
        }
        .active .glitch-text::after {
            animation: glitch-anim-2 3s infinite linear alternate-reverse;
        }
        @keyframes glitch-anim-1 { 0% { clip: rect(42px, 9999px, 44px, 0); transform: skew(0.5deg); } 10% { clip: rect(10px, 9999px, 50px, 0); transform: skew(0.1deg); } 20% { clip: rect(80px, 9999px, 85px, 0); transform: skew(0.8deg); } 30% { clip: rect(30px, 9999px, 35px, 0); transform: skew(0.2deg); } 40% { clip: rect(50px, 9999px, 55px, 0); transform: skew(0.4deg); } 50% { clip: rect(15px, 9999px, 20px, 0); transform: skew(0.6deg); } 60% { clip: rect(70px, 9999px, 75px, 0); transform: skew(0.1deg); } 70% { clip: rect(5px, 9999px, 10px, 0); transform: skew(0.3deg); } 80% { clip: rect(60px, 9999px, 65px, 0); transform: skew(0.7deg); } 90% { clip: rect(25px, 9999px, 30px, 0); transform: skew(0.2deg); } 100% { clip: rect(85px, 9999px, 90px, 0); transform: skew(0.5deg); } }
        @keyframes glitch-anim-2 { 0% { clip: rect(15px, 9999px, 20px, 0); transform: skew(0.5deg); } 10% { clip: rect(60px, 9999px, 65px, 0); transform: skew(0.2deg); } 20% { clip: rect(35px, 9999px, 40px, 0); transform: skew(0.6deg); } 30% { clip: rect(70px, 9999px, 75px, 0); transform: skew(0.1deg); } 40% { clip: rect(5px, 9999px, 10px, 0); transform: skew(0.3deg); } 50% { clip: rect(42px, 9999px, 44px, 0); transform: skew(0.8deg); } 60% { clip: rect(80px, 9999px, 85px, 0); transform: skew(0.5deg); } 70% { clip: rect(10px, 9999px, 50px, 0); transform: skew(0.1deg); } 80% { clip: rect(50px, 9999px, 55px, 0); transform: skew(0.4deg); } 90% { clip: rect(30px, 9999px, 35px, 0); transform: skew(0.2deg); } 100% { clip: rect(85px, 9999px, 90px, 0); transform: skew(0.6deg); } }
        @keyframes glitch-skew { 0% { transform: skew(1deg); } 50% { transform: skew(-1deg); } 100% { transform: skew(1deg); } }
        .flow-svg { overflow: visible; }
        .flow-line { stroke: #10B981; stroke-width: 3; stroke-dasharray: 1000; stroke-dashoffset: 1000; transition: stroke-dashoffset 1.5s ease-out 0.8s; }
        .active .flow-line { stroke-dashoffset: 0; }
    </style>
</head>
<body>

    <a href="https://spotorigin.com" target="_blank" rel="noopener noreferrer" 
       class="fade-in-button fixed top-6 right-6 z-[1002] bg-indigo-600 text-white text-lg font-bold px-6 py-3 rounded-full shadow-lg hover:bg-indigo-500 transition-all duration-300">
       Candidate? Click here.
    </a>
    <canvas id="orb-canvas"></canvas>

    <main id="deck-container">
        
        <section id="slide-1" class="slide">
            </section>

        <section id="slide-2" class="slide">
            </section>

        <section id="slide-3" class="slide slide-content-layout">
            </section>

        <section id="slide-4" class="slide slide-content-layout">
            </section>

        <section id="slide-5" class="slide slide-content-layout">
             </section>
        
        <section id="slide-6" class="slide slide-content-layout">
            </section>

        <section id="slide-7" class="slide slide-content-layout">
            </section>

        <section id="slide-8" class="slide slide-content-layout">
            </section>

        <section id="slide-9" class="slide slide-content-layout">
            </section>
        
        <section id="slide-10" class="slide slide-content-layout">
            </section>

        <section id="slide-11" class="slide">
            </section>


    </main>

    <div class="progress-bar-container">
        <div id="progress-bar"></div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const slides = document.querySelectorAll('.slide');
            const container = document.getElementById('deck-container');
            const progressBar = document.getElementById('progress-bar');
            const canvas = document.getElementById('orb-canvas');
            let currentSlideIndex = 0;

            // --- 1. Automated Staggering Setup ---
            const setupStaggering = () => {
                document.querySelectorAll('[data-stagger]').forEach(container => {
                    const items = container.querySelectorAll('.reveal-item');
                    items.forEach((item, index) => {
                        item.style.transitionDelay = `${0.1 + (index * 0.15)}s`;
                        item.setAttribute('data-staggered', 'true');
                    });
                });
                const finalMetric = document.getElementById('final-metric');
                if (finalMetric) {
                    finalMetric.style.transitionDelay = '0.7s'; 
                    finalMetric.setAttribute('data-staggered', 'true');
                }
            };

            // --- 2. [REFACTORED] Animated Counters ---
            const animateCounters = (activeSlide) => {
                const counters = activeSlide.querySelectorAll('.counter');
                counters.forEach(counter => {
                    // The old "one-and-done" guard has been removed.
                    const target = +counter.getAttribute('data-target');
                    const duration = 1500;
                    const startTime = performance.now();
                    const format = counter.getAttribute('data-format') || 'number';

                    const updateCount = (currentTime) => {
                        const elapsedTime = currentTime - startTime;
                        const progress = Math.min(elapsedTime / duration, 1);
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        const divisor = (format === 'percent' && target !== 100 && target < 100) ? 10 : 1;
                        let current;
                        if (format === 'percent') {
                             current = (easedProgress * target) / divisor;
                        } else {
                            current = Math.floor(easedProgress * target);
                        }
                        if (format === 'percent') {
                             counter.innerText = (divisor === 1 ? Math.floor(current) : current.toFixed(1)) + '%';
                        } else {
                            counter.innerText = current.toLocaleString();
                        }
                        if (progress < 1) {
                            requestAnimationFrame(updateCount);
                        } else {
                             if (format === 'percent') {
                                 counter.innerText = (divisor === 1 ? target : (target / 10).toFixed(1)) + '%';
                             } else {
                                counter.innerText = target.toLocaleString();
                             }
                        }
                    };
                    setTimeout(() => requestAnimationFrame(updateCount), 300);
                });
            };

            // --- 3. [NEW] Animation Reset Function ---
            // This function is called on any slide that becomes INACTIVE.
            const resetSlide = (slide) => {
                const counters = slide.querySelectorAll('.counter');
                counters.forEach(counter => {
                    // Reset the counter text to its initial state.
                    const format = counter.getAttribute('data-format') || 'number';
                    if (format === 'percent') {
                        counter.innerText = '0%';
                    } else {
                        counter.innerText = '0';
                    }
                });
                // CSS-based animations like reveal items and the glitch text reset automatically
                // when the '.active' class is removed, so we don't need to handle them here.
            };


            // --- 4. [REFACTORED] Slide State Management ---
            const updateSlideStates = (newIndex) => {
                // Only run if the index has actually changed
                if (newIndex === currentSlideIndex) return;

                slides.forEach((slide, index) => {
                    if (index === newIndex) {
                        // This is the new active slide
                        slide.classList.add('active');
                        // Trigger JS-based animations for it
                        if (slide.id === 'slide-3' || slide.id === 'slide-5') {
                            animateCounters(slide);
                        }
                    } else {
                        // This slide is now inactive
                        slide.classList.remove('active');
                        resetSlide(slide); // Reset its state
                    }
                });
                
                currentSlideIndex = newIndex;

                // Update progress bar and parallax effect
                const progress = ((currentSlideIndex + 1) / slides.length) * 100;
                progressBar.style.width = `${progress}%`;
                const parallaxOffset = currentSlideIndex * -50;
                canvas.style.transform = `translateY(${parallaxOffset}px)`;
            };

            // --- 5. Scroll Detection (Intersection Observer) ---
            // This logic remains largely the same but now calls the more robust updateSlideStates.
            const observerOptions = {
                root: container,
                rootMargin: '0px',
                threshold: 0.5 
            };
            const observerCallback = (entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const index = Array.from(slides).indexOf(entry.target);
                        updateSlideStates(index);
                    }
                });
            };
            const observer = new IntersectionObserver(observerCallback, observerOptions);
            slides.forEach(slide => observer.observe(slide));

            
            // --- 6. Keyboard Navigation ---
             const scrollToSlide = (index) => {
                if (index >= 0 && index < slides.length) {
                    slides[index].scrollIntoView({ behavior: 'smooth' });
                }
            };
            window.addEventListener('keydown', (e) => {
                let targetIndex = currentSlideIndex;
                if (e.key === 'ArrowRight' || e.key === 'ArrowDown' || e.key === 'PageDown' || (e.code === 'Space' && !e.shiftKey)) {
                    e.preventDefault();
                    targetIndex = currentSlideIndex + 1;
                } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp' || e.key === 'PageUp' || (e.code === 'Space' && e.shiftKey)) {
                    e.preventDefault();
                    targetIndex = currentSlideIndex - 1;
                }
                if (targetIndex !== currentSlideIndex) {
                    scrollToSlide(targetIndex);
                }
            });

             // --- 7. Dynamic Orb Background (Canvas Animation) ---
            // This logic is unchanged.
            const ctx = canvas.getContext('2d');
            function resizeCanvas() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; }
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            const colors = [ { r: 99, g: 102, b: 241 }, { r: 139, g: 92, b: 246 }, { r: 236, g: 72, b: 153 } ];
            class Orb { /* ... Orb class definition is unchanged ... */ }
            const orbs = [];
            for (let i = 0; i < 6; i++) { orbs.push(new Orb(i)); }
            function animateCanvas() { ctx.clearRect(0, 0, canvas.width, canvas.height); orbs.forEach(orb => { orb.update(); orb.draw(); }); requestAnimationFrame(animateCanvas); }

            // --- Initialization ---
            setupStaggering();
            animateCanvas();
            // Initialize the first slide correctly
            setTimeout(() => {
                slides.forEach((slide, index) => {
                    if (index !== 0) resetSlide(slide);
                });
                slides[0].classList.add('active');
                if (slides[0].id === 'slide-3' || slides[0].id === 'slide-5') {
                    animateCounters(slides[0]);
                }
                updateSlideStates(0); // Set initial state without triggering animation loop
            }, 100);
        });
    </script>
    <script>
        // --- SCROLL ANALYTICS (IntersectionObserver) ---
        // This logic is unchanged.
        document.addEventListener('DOMContentLoaded', () => {
            const formUrl = 'https://formspree.io/f/mqaynjdl';
            const sectionsAlreadySeen = new Set();
            const sendAnalyticsEvent = (sectionId) => { if (!sectionId) return; const formData = new FormData(); formData.append('slide_reached', sectionId); formData.append('page_url', window.location.href); formData.append('timestamp', new Date().toISOString()); if (navigator.sendBeacon) { navigator.sendBeacon(formUrl, formData); } else { fetch(formUrl, { method: 'POST', body: formData, keepalive: true }); } };
            const observerCallback = (entries, observer) => { entries.forEach(entry => { if (entry.isIntersecting) { const sectionId = entry.target.id; if (!sectionsAlreadySeen.has(sectionId)) { sectionsAlreadySeen.add(sectionId); sendAnalyticsEvent(sectionId); observer.unobserve(entry.target); } } }); };
            const observerOptions = { root: document.getElementById('deck-container'), threshold: 0.5, };
            const observer = new IntersectionObserver(observerCallback, observerOptions);
            const sectionsToTrack = document.querySelectorAll('.slide');
            sectionsToTrack.forEach(section => { observer.observe(section); });
        });
    </script>
</body>
</html>